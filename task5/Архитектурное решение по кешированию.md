**Мотивация**

Пробуем решить проблему операторов с тем, что стартовая страница долго грузится. Одна из возможных версий - запрос по получению заказов работает очень долго, или БД систематически перегружено, и предварительное сохранение без дальнейшего захода в базу решит проблему.

Кэшировать будем запросы MES API к MES DB (через интерфейс MES). Почему это имеет смысл:
1. Операторы быстрее будут брать заказ в работу, если это решит проблему
2. Не будет такого, что заказ очень долго не брали в работу, он уехал вниз из-за новых заказов, и его просто "потеряли"
3. Некоторое снижение нагрузки на базу MES DB


**Предлагаемое решение**

В формате [puml](/task5/sequence_diagram.puml)

![](/task5/sequence_diagram.PNG)


*Разбор паттернов кэширования*

- Cache Aside - самый понятный и распространенный вариант, не требующий DBA или прочих специфических знаний БД. В условиях дефицита ресурсов и нехватки экспертизы может быть самым выигрышным вариантом.
- Read-Through + Write-Through - очень не хватает внутренней информации: сколько в целом запросов на чтение/запись, насколько много данных, как часто после первого чтения или изменения данные действительно востребованы, чтобы их сразу помещать в кэш? Без этих данных не стал бы предлагать реализацию через эти паттерны. 
- Refresh Ahead + Write-Behind - выглядит интересно. Через Refresh Ahead выталкиваем в кэш все изменения, которые произошли с заказом на стадии производства, а за счет асинхронного Write-Behind упрощаем запись. Из минусов здесь вижу сложную настройку для неопытной команды, отягощаемое уже разваливающейся системой.


Т.к. информации о соотношении количества операций на чтение и запись нет, предположу следующие варианты:
1. Cache Aside наиболее предпочтительный вариант с точки зрения понятности и простоты настройки. В системе, где уже куча проблем, создавать ещё одно потенциально уязвимое место кажется неправильным. Пусть кэш будет в стороне. Упадет - поднимем, не страшно. Этот вариант и нарисован на диаграмме последовательностей. Важно: если соотношение операций чтения к записи хотя бы 75 на 25 (или чтения выше), то вообще отличный вариант.
2. Refresh Ahead + Write-Behind - это более зрелый и универсальный вариант. По идее тут намного меньшая зависимость от соотношения операций чтения/записи (при сильном перекосе чтения или записи просто убирается один из двух паттернов). Но очень пугает настройка и дальнейшая поддержка, когда у нас MES API ещё не разобран даже. Отложил бы этот вариант до момента выправления ситуации с потерянными заказами.

*Итоговое решение по паттерну кэширования*

Получаем информацию о соотношении количества операций на чтение и запись. В зависимости от результата:
1. Если чтения 75% и выше - реализуем Cache Aside
2. Если меньше - Refresh Ahead + Write-Behind

*Разбор вариантов инвалидаций*

- Временная инвалидация - подходит, но только в совокупности с любой другой стратегией, учитывающей реакцию на изменения
- Инвалидация, основанная на запросах - может подойти в каких-то случаях, но, кажется, есть более удачные варианты
- Инвалидация на основе изменений - подходит, если это не слишком часто происходит. Т.к. это ювелирка, не думаю, что тут каждую минуту заказы сыпятся, а станки массово штампуют разные типы колец.
- Программная инвалидация - может подойти, зависит от бизнес-логики. Например, если сделанная деталь влияет на приоритет взятия в работу других деталей
- Инвалидация по ключу - опять же зависит от частоты поступления данных. В целом подходит, т.к. заказы между собой время ли будут пересекаться, поэтому изменения в цикле производства заказа позволят инвалидировать только конкретный заказ

Не хватает данных по объемам заказа и процессу производства. Без них предположу следующие варианты:
1. Временная + Программная - если очень сложная бизнес-логика
2. Временная + По ключу - если не запутанная логика, где заказы друг на друга влияют
3. Временная + На основе изменений - если процесс довольно простой, а сами изменения не очень частые

*Итоговое решение по инвалидации*

Получаем информацию по объемам заказов и процессам производства. Исходя из них выбираем один из следующих вариантов:
1. Временная + Программная - если очень сложная бизнес-логика
2. Временная + По ключу - если не запутанная логика, где заказы друг на друга влияют
3. Временная + На основе изменений - если процесс довольно простой, а сами изменения не очень частые

*Дополнительный комментарий по диаграмме последовательностей*. На ней не включил POST (добавление нового заказа) в инвалидацию кэша. Подразумевал, что инфомарция о новом заказе появится как раз после временной инвалидации. Чтобы чуть реже дергать кэш. А клиент вряд ли расстроится, если оператор возьмет в работу заказ на N минут позже. А если там ещё и очередь из заказов на дни-недели вперёд, то клиент даже и не увидит разницы. При этом ничего не мешает добавить POST к инвалидации как все остальные CRUD операции.
