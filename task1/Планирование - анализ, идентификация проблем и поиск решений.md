**Проблемы и инициативы**

Ключевая проблема - потеря заказов. Это critical - уже привело к финансовым и репутационным потерям. Все задачи первого приоритета будут направлены на решение этой проблемы.
1. Отсутствие observability
- нет возможности отследить весь путь заказа (трейсинг)
- нет возможности понять, в чём именно была ошибка, в какой момент (логирование)
- нет понимания, какая нагрузка на систему, в целом какой процент выполненных заказов до обращения клиентов (мониторинг)
2. Отсутствие безопасности. Сейчас пользователи практически напрямую вызывают MES API. Это вызывает ряд проблем и вопросов:
- возможна DDOS атака
- возможны кривые запросы
- все проверки, валидации, регистрация заказа происходит в MES API. Кажется, что валидация должна быть отдельной, на этапе принятия заказа. И только выполнение заказа оставлять в MES API. Сам заказ должен появляться в мастер-системе - CRM или новый отдельный сервис
3. Вынос работы с сущностью "заказы" в отдельный микросервис. По заданию не очень понятно - хранится ли заказ как сущность в едином формате, но в разных системах и БД, ИЛИ это передача разрозненных данных между системами в зависимости от статуса. В первом случае у нас нет единой мастер-системы с соответствующими последствиями, во втором повышенные шансы потерь и ошибок
4. Из общего описания сделал предположение, что заказы могут теряться между очередью и MES API: на CRM жалоб не было (до очереди), зато на долгое время анализа заказов и медленную работу фронта были (относится к MES API). Гипотеза - сервис берет в работу сообщение из rabbitmq, и дальше либо сразу шлёт ack и теряет заказ в процессе обработки, либо получает сообщение, слишком долго не шлёт ack (т.к. перегружен), rabbitmq рвёт по таймауту, и сообщение теряется. Сам MES API перекапывать может оказаться долго - нет экспертизы по сервису (плюс нет уверенного полноценного разработчика на React) и слишком много проблем. Поэтому возможны следующие варианты:
- проверить, как настроен RabbitMQ - дожидается ли он ответа от MES API, включен ли механизм досылки сообщений, если изначально MES API оказался недоступен
- прокси-сервис между MES API и RabbitMq, на знакомом нам Spring Boot, который будет тупо вычитывать очередь, сохранять сообщение в БД, и отправлять в MES API
- переход с RabbitMq (push) на Kafka (pull) - сомнительно, но как вариант. Чтобы сервис сам по мере высвобождения вычитывал записи
5. Рефакторинг MES API. На него жалуются со всех сторон. Кажется, что нужно тут оставлять только расчёт + продумывать масштабирование, всё остальное выносить в отдельные сервисы и БД.


Другие проблемы, которые не внёс в список выше:
1. Сложные модели рассчитываются 30 минут, обычные 2-3 минуты. Главное - не это причина недовольства клиентов. Это внутренний расчёт MES-системы. Да, исходный код куплен, но в нём нужно разбираться, как оптимизировать. Задача долгая, т.к. новый код и другая технология (React и C#), 0 экспертизы. Перекликается с пунктом 5.
2. Долгая прогрузка стартовой страницы MES системы. Влияет на внутреннюю работу, но не влияет на клиентов напрямую, то есть финансовых потерь нет. Итого - задача не самая приоритетная. Но если в процессе анализа окажется, что фронт при запросе заказов грузит БД и это дальше аффектит работу всего остального, то становится критичной.
3. "жалоб от клиентов на просроченные заказы стало ещё больше" - тоже интересный кейс. То есть заказ не теряется, но почему-то месяцами может не браться в работу. Получается, нет нормальной системы отображения всех заказов, статусов и т.д., хотя есть MES со свои (хоть и тормозящим) фронтом
4. 3d files storage вызывает опасения. В него ходят сразу 3 крупные системы. Логичнее было бы сделать единую точку входа, тогда и отслеживать нагрузку и проблемы было бы проще, и потенциальные проблемы с безопасностью через роли можно было бы решить

**Исходя из всего вышеописанного, топ-3 задачи сделал бы следующие:**

1. Блок с очередью RabbitMQ:
- добавить логирование и мониторинг со стороны продюсера и со стороны консьюмера
- проверить настройки RabbitMQ на доставку сообщений в случае сбоев на стороне MES API
- реализовать backpressure силами внутренних настроек RabbitMQ
*по результатам логирования определяем следующую задачу - прокси-сервис перед MES API, переход на Kafka, сразу рефакторинг MES API
2. Алертинг на просроченные заказы. Интерфейс плохо работает + React с половиной разработчика, поэтому пока делаем простейший отчёт по "зависшим" заказам, которые нужно отправить на производство - отправка эксельки руководителю операторов. Запасной вариант - временную страницу на Vue (т.е. в отдельном интерфейсе). Все решения нецелевые, но хотим в первый месяц убрать хотя бы этот блок негатива
3. Оптимизация в MES API. Это долгая задача, но когда-то в любом случае надо начинать разбираться.

В результате 2 джависта и девопс сидят на первых двух задачах, один C# и парт тайм тимлид на рефакторинге MES. Vue фронтенд на поддержке и потенциально на второй задаче, второй Vue фронтенд восстанавливает React и погружается в 3 задачу.

**Что бы изменилось через полгода:**

1. Мониторинг на все подсистемы
    a. есть четкое понимание, на каком этапе возникали ошибки
    b. понимание, какую нагрузку мы спокойно тянем сейчас, какая наша предельная нагрузка. Чтобы быть готовым к дальнейшему расширению
    c. какие заказы не были взяты в работу. Пользователи знают, что их заказ не был взят в работу. Сами такие кейсы снижены в разы (см пункт ниже)
2. Благодаря мониторингу количество ошибок в принципе снизилось в разы:
    a. работа бэка MES API оптимизирована. Очень обтекаемая формулировка, но тут что угодно может быть. Возможные варианты оптимизации:
        - в MES API остался только функционал по расчёту стоимости и формированию заказа для производства
        - БД MES API масштабирована
        - API пользователей не ходит напрямую в MES API - это может быть Circuit Breaker, DMZ, отдельный микросервис с логикой проверки и валидацией данных и т.д.
    b. работа фронта оптимизирована. Решена проблема стартовой страницы, интерфейс стал более функциональным - например, выводятся просроченные заказы
    с. работа RabbitMQ оптимизирована (в т.ч. за счет настроек) и мы по 100% кейсам понимаем, что происходит с заказами на входе/выходе, ни один кейс не теряется
3. Составлены планы (или даже уже начата реализация) по глобальным архитектурным задачам:
    a. приведение в порядок работы с заказами - вынос в отдельный микросервис/БД
    b. 3d files storage имеет только одну точку входа
4. За счёт четкого понимания работы системы и дальнейших планов - согласованные квоты на новый найм. Выглядит так, что как минимум не помешает найм команды первой и второй линий поддержки (первая - с клиентами, вторая - мониторинг, алертинг, релиз-менеджмент)